{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ObserveRTC \u00b6 ObserveRTC is an open source initiative aimed to provide tools to collect, interpret, and visualize WebRTC metrics in real-time. Benefits of collecting WebRTC stats \u00b6 Performance tuning - Ability to debug/improve your WebRTC applications. Regression analysis - Quantify the impact of changes you made. System operations - Measure and monitor the performance of your application. Troubleshooting & debugging - Investigate technical issues. Usage trends - Track/Undetstand how your app is used. Use cases \u00b6 As an application developer you can use ObserveRTC to debug your WebRTC applications. As a product owner you can use ObserveRTC to measure and monitor the performance of your application. As an operations team member you can monitor the health and get critical alerts about your application. Why to choose ObserveRTC? \u00b6 Open source and designed to be integrated with other open-source solutions. Own the data from your applications and run further analysis. Designed for the cloud. When the size of your memory and compute requirements increase, new resources can be dynamically added to your cluster to scale elastically. e.g. hazelcast as an in-memory distributed databse for resiliance.","title":"Home"},{"location":"#observertc","text":"ObserveRTC is an open source initiative aimed to provide tools to collect, interpret, and visualize WebRTC metrics in real-time.","title":"ObserveRTC"},{"location":"#benefits-of-collecting-webrtc-stats","text":"Performance tuning - Ability to debug/improve your WebRTC applications. Regression analysis - Quantify the impact of changes you made. System operations - Measure and monitor the performance of your application. Troubleshooting & debugging - Investigate technical issues. Usage trends - Track/Undetstand how your app is used.","title":"Benefits of collecting WebRTC stats"},{"location":"#use-cases","text":"As an application developer you can use ObserveRTC to debug your WebRTC applications. As a product owner you can use ObserveRTC to measure and monitor the performance of your application. As an operations team member you can monitor the health and get critical alerts about your application.","title":"Use cases"},{"location":"#why-to-choose-observertc","text":"Open source and designed to be integrated with other open-source solutions. Own the data from your applications and run further analysis. Designed for the cloud. When the size of your memory and compute requirements increase, new resources can be dynamically added to your cluster to scale elastically. e.g. hazelcast as an in-memory distributed databse for resiliance.","title":"Why to choose ObserveRTC?"},{"location":"quick-start/step-1-observer/","text":"Stats Interpretation (Docker) \u00b6 Pre-Requisites \u00b6 install docker-compose https://docs.docker.com/compose/install/ If you want to customize any Kafka parameters, simply add them as environment variables in docker-compose.yml. Kafka's log4j usage can be customized by adding environment variables prefixed with LOG4J_. Usage \u00b6 In order to quickly run WebRTC-Observer on a host running Docker and Docker Compose, follow these steps: Clone this repository git clone https://github.com/ObserveRTC/docker-webrtc-observer.git Run docker-compose up Hazelcast configuration \u00b6 The Observer uses hazelcast as an IMDG, and all the configuration related to hazelcast is in hazelcast-config.yml, which is automatically mounted in the docker when you run it.","title":"Step 1 Deploy observer"},{"location":"quick-start/step-1-observer/#stats-interpretation-docker","text":"","title":"Stats Interpretation (Docker)"},{"location":"quick-start/step-1-observer/#pre-requisites","text":"install docker-compose https://docs.docker.com/compose/install/ If you want to customize any Kafka parameters, simply add them as environment variables in docker-compose.yml. Kafka's log4j usage can be customized by adding environment variables prefixed with LOG4J_.","title":"Pre-Requisites"},{"location":"quick-start/step-1-observer/#usage","text":"In order to quickly run WebRTC-Observer on a host running Docker and Docker Compose, follow these steps: Clone this repository git clone https://github.com/ObserveRTC/docker-webrtc-observer.git Run docker-compose up","title":"Usage"},{"location":"quick-start/step-1-observer/#hazelcast-configuration","text":"The Observer uses hazelcast as an IMDG, and all the configuration related to hazelcast is in hazelcast-config.yml, which is automatically mounted in the docker when you run it.","title":"Hazelcast configuration"},{"location":"quick-start/step-2-1-jitsi-integration/","text":"Stats Collection for Jitsi \u00b6 Integrate the observerRTC library in your Jitsi Meet HTML \u00b6 To load the observerRTC library, we need to edit the Jitsi Meet webpage. Open your JitsiMeet index.html page: \u00b6 nano /usr/share/jitsi-meet/index.html Add these two file after the line where config.js script is loaded: \u00b6 < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" >< /script> < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/jitsi.integration.min.js\" >< /script> This should look something like: <!--... --> <!--#include virtual=\"static/settingsToolbarAdditionalContent.html\" --> <!-- Added manually as part of Observe RTC installation; using full, unminified versions --> < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script > < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/jitsi.integration.min.js\" ></ script > </ head > < body > <!--#include virtual=\"body.html\" --> < div id = \"react\" ></ div > </ body > </ html > Configure your Jitsi project to send stats to observer \u00b6 For existing installations and typical deployments you can simply add a few lines to the end of the meet-[your-domain]-config.js configuration file. This is usually located under /etc/jitsi/meet in the Debian installation. Edit config.js in your already installed jitsi-meet \u00b6 Goto your config.js file from jitsi-meet config folder. nano /etc/jitsi/meet/meet.my.domain-config.js Add these two implementation specific variable at the very end of the file. config . analytics . observerPoolingIntervalInMs = 1000 config . observerWsEndpoint = \"wss://{OBSERVER_WS_ENDPOINT}/service_uuid/media_unit_id/stats_version/json\" Make sure to specify your service_uuid and a unique string for media_unit_id to identify this specific Jitsi Meet instance. You need to set the {OBSERVER_WS_ENDPOINT} based on the observer deployment, you can set this later after you deploy Observer in your environment. Docker builds \u00b6 Do the following if you are building from Docker. You will need to pass the integration specific configuration using config.js before building the container. Goto your jitsi-meet settings-config.js and add the following: // observer rtc related config {{ if . Env . POOLING_INTERVAL_IN_MS - }} config . analytics . observerPoolingIntervalInMs = '{{ .Env.OBSERVER_POOLING_INTERVAL_IN_MS }}' ; {{ end - }} {{ if . Env . OBSERVER_WS_ENDPOINT - }} config . observerWsEndpoint = '{{ .Env.OBSERVER_WS_ENDPOINT }}' ; {{ end - }} Now, if we build a new jitsi-meet container, these two environment variable will be present in config.js when jitsi-meet is loaded. You need to set the {OBSERVER_WS_ENDPOINT} based on the observer deployment, you can set this later after you deploy Observer in your environment. Reload the Jitsi Meet page from browser to apply changes. Jitsi Meet now integrated. \u00b6","title":"Jitsi"},{"location":"quick-start/step-2-1-jitsi-integration/#stats-collection-for-jitsi","text":"","title":"Stats Collection for Jitsi"},{"location":"quick-start/step-2-1-jitsi-integration/#integrate-the-observerrtc-library-in-your-jitsi-meet-html","text":"To load the observerRTC library, we need to edit the Jitsi Meet webpage.","title":"Integrate the observerRTC library in your Jitsi Meet HTML"},{"location":"quick-start/step-2-1-jitsi-integration/#open-your-jitsimeet-indexhtml-page","text":"nano /usr/share/jitsi-meet/index.html","title":"Open your JitsiMeet  index.html page:"},{"location":"quick-start/step-2-1-jitsi-integration/#add-these-two-file-after-the-line-where-configjs-script-is-loaded","text":"< script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" >< /script> < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/jitsi.integration.min.js\" >< /script> This should look something like: <!--... --> <!--#include virtual=\"static/settingsToolbarAdditionalContent.html\" --> <!-- Added manually as part of Observe RTC installation; using full, unminified versions --> < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script > < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/jitsi.integration.min.js\" ></ script > </ head > < body > <!--#include virtual=\"body.html\" --> < div id = \"react\" ></ div > </ body > </ html >","title":"Add these two file after the line where config.js script is loaded:"},{"location":"quick-start/step-2-1-jitsi-integration/#configure-your-jitsi-project-to-send-stats-to-observer","text":"For existing installations and typical deployments you can simply add a few lines to the end of the meet-[your-domain]-config.js configuration file. This is usually located under /etc/jitsi/meet in the Debian installation.","title":"Configure your Jitsi project to send stats to observer"},{"location":"quick-start/step-2-1-jitsi-integration/#edit-configjs-in-your-already-installed-jitsi-meet","text":"Goto your config.js file from jitsi-meet config folder. nano /etc/jitsi/meet/meet.my.domain-config.js Add these two implementation specific variable at the very end of the file. config . analytics . observerPoolingIntervalInMs = 1000 config . observerWsEndpoint = \"wss://{OBSERVER_WS_ENDPOINT}/service_uuid/media_unit_id/stats_version/json\" Make sure to specify your service_uuid and a unique string for media_unit_id to identify this specific Jitsi Meet instance. You need to set the {OBSERVER_WS_ENDPOINT} based on the observer deployment, you can set this later after you deploy Observer in your environment.","title":"Edit config.js in your already installed jitsi-meet"},{"location":"quick-start/step-2-1-jitsi-integration/#docker-builds","text":"Do the following if you are building from Docker. You will need to pass the integration specific configuration using config.js before building the container. Goto your jitsi-meet settings-config.js and add the following: // observer rtc related config {{ if . Env . POOLING_INTERVAL_IN_MS - }} config . analytics . observerPoolingIntervalInMs = '{{ .Env.OBSERVER_POOLING_INTERVAL_IN_MS }}' ; {{ end - }} {{ if . Env . OBSERVER_WS_ENDPOINT - }} config . observerWsEndpoint = '{{ .Env.OBSERVER_WS_ENDPOINT }}' ; {{ end - }} Now, if we build a new jitsi-meet container, these two environment variable will be present in config.js when jitsi-meet is loaded. You need to set the {OBSERVER_WS_ENDPOINT} based on the observer deployment, you can set this later after you deploy Observer in your environment.","title":"Docker builds"},{"location":"quick-start/step-2-1-jitsi-integration/#reload-the-jitsi-meet-page-from-browser-to-apply-changes-jitsi-meet-now-integrated","text":"","title":"Reload the Jitsi Meet page from browser to apply changes. Jitsi Meet now integrated."},{"location":"quick-start/step-2-2-tokbox-integration/","text":"Stats Collection for TokBox \u00b6 OpenTok Quickstart \u00b6 Include core library \u00b6 You should do this before including opentok.js file in your html page. We have a public version hosted on GitHub you can use as shown below. < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script > Define server endpoint in global( window ) scope \u00b6 < script > let observerWsEndPoint = ObserverRTC . ParserUtil . parseWsServerUrl ( \"{OBSERVER_WS_ENDPOINT}\" , // observerURL \"{ServiceUUID}\" , // Add a unique ServiceUUID here \"{Your_Service_name}\" , // MediaUnitID \"v20200114\" // getStats-version ); </ script > Include the integration library \u00b6 Minified version: < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/tokbox.integration.min.js\" ></ script > In the end it might look similiar to this < html > < body > <!-- ..... ..... --> < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script > < script > let observerWsEndPoint = ObserverRTC . ParserUtil . parseWsServerUrl ( \"ws://localhost:8088/\" , // observerURL \"b8bf0467-d7a9-4caa-93c9-8cd6e0dd7731\" , // Add a unique ServiceUUID here \"opentok-demo\" , // MediaUnitID \"v20200114\" // StatsVersion ); </ script > < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/tokbox.integration.min.js\" ></ script > < script src = \"https://static.opentok.com/v2/js/opentok.js\" charset = \"utf-8\" ></ script >","title":"Tokbox"},{"location":"quick-start/step-2-2-tokbox-integration/#stats-collection-for-tokbox","text":"","title":"Stats Collection for TokBox"},{"location":"quick-start/step-2-2-tokbox-integration/#opentok-quickstart","text":"","title":"OpenTok Quickstart "},{"location":"quick-start/step-2-2-tokbox-integration/#include-core-library","text":"You should do this before including opentok.js file in your html page. We have a public version hosted on GitHub you can use as shown below. < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script >","title":"Include core library"},{"location":"quick-start/step-2-2-tokbox-integration/#define-server-endpoint-in-global-window-scope","text":"< script > let observerWsEndPoint = ObserverRTC . ParserUtil . parseWsServerUrl ( \"{OBSERVER_WS_ENDPOINT}\" , // observerURL \"{ServiceUUID}\" , // Add a unique ServiceUUID here \"{Your_Service_name}\" , // MediaUnitID \"v20200114\" // getStats-version ); </ script >","title":"Define server endpoint in global( window ) scope"},{"location":"quick-start/step-2-2-tokbox-integration/#include-the-integration-library","text":"Minified version: < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/tokbox.integration.min.js\" ></ script > In the end it might look similiar to this < html > < body > <!-- ..... ..... --> < script src = \"https://observertc.github.io/observer-js/dist/v0.3.5/observer.min.js\" ></ script > < script > let observerWsEndPoint = ObserverRTC . ParserUtil . parseWsServerUrl ( \"ws://localhost:8088/\" , // observerURL \"b8bf0467-d7a9-4caa-93c9-8cd6e0dd7731\" , // Add a unique ServiceUUID here \"opentok-demo\" , // MediaUnitID \"v20200114\" // StatsVersion ); </ script > < script src = \"https://observertc.github.io/integrations/dist/v0.0.2/tokbox.integration.min.js\" ></ script > < script src = \"https://static.opentok.com/v2/js/opentok.js\" charset = \"utf-8\" ></ script >","title":"Include the integration library"},{"location":"quick-start/step-3-observer-connector/","text":"Stats Connector \u00b6","title":"Step 3 Deploy observer-connector"},{"location":"quick-start/step-3-observer-connector/#stats-connector","text":"","title":"Stats Connector"},{"location":"quick-start/step-4-observer-visualiser/","text":"Stats Visualisation \u00b6","title":"Step 4 Visualise"},{"location":"quick-start/step-4-observer-visualiser/#stats-visualisation","text":"","title":"Stats Visualisation"},{"location":"team/team/","text":"ObserveRTC Team \u00b6 Balazs Kreith \u00b6 Balazs Kreith is an open source developer and software architect. Binoy Chemmagate \u00b6 Binoy Chemmagate is an RTC product manager and tech enthusiast. Chad Hart \u00b6 Chad Hart is an RTC consultant and tech enthusiast. Pallab Gain \u00b6 Pallab Gain is an open source developer and software architect.","title":"Members"},{"location":"team/team/#observertc-team","text":"","title":"ObserveRTC Team"},{"location":"team/team/#balazs-kreith","text":"Balazs Kreith is an open source developer and software architect.","title":"Balazs Kreith"},{"location":"team/team/#binoy-chemmagate","text":"Binoy Chemmagate is an RTC product manager and tech enthusiast.","title":"Binoy Chemmagate"},{"location":"team/team/#chad-hart","text":"Chad Hart is an RTC consultant and tech enthusiast.","title":"Chad Hart"},{"location":"team/team/#pallab-gain","text":"Pallab Gain is an open source developer and software architect.","title":"Pallab Gain"}]}